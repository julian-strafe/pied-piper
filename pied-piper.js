const fs = require('fs')
const path = require('path')

// Default configuration (overridden by .piedpiper.json if present)
const defaultConfig = {
  targetFolder: 'pipe',
  ignoredFolders: ['node_modules', 'pipe', '.git', 'dist'],
  ignoredFiles: [
    'package-lock.json',
    'pied-piper.js', // Ignore the script itself
    '.gitignore',
    '.prettierrc',
    '.env',
    'README.md', // Ignore the project root README
    '.firebaserc',
  ],
  ignoredPatterns: ['*.log', '*.cache', '*.svg'],
  extensionsToAppendTxt: ['.rules', '.jsx'], // Append .txt to these extensions and files with no extension
}

// --- Configuration Loading ---
let config = { ...defaultConfig }
const configPath = path.join(process.cwd(), '.piedpiper.json')
try {
  if (fs.existsSync(configPath)) {
    const userConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'))
    config = { ...defaultConfig, ...userConfig } // User config overrides defaults
    console.log('Loaded configuration from .piedpiper.json')
  }
} catch (error) {
  console.error('Error loading .piedpiper.json:', error)
  console.log('Using default configuration.')
}

// --- Filter Argument ---
const filterArg = process.argv[2]
if (filterArg) {
  console.log(`Filtering files where path/name contains: ${filterArg}`)
}

// --- Core Functions ---

function clearTargetFolder() {
  const target = config.targetFolder
  if (fs.existsSync(target)) {
    console.log(`Clearing existing target folder: ${target}`)
    fs.readdirSync(target).forEach((file) => {
      const filePath = path.join(target, file)
      try {
        // Avoid deleting the generated README if it exists and is the only thing left
        if (
          path.basename(filePath) !== 'README.md' ||
          fs.readdirSync(target).length > 1
        ) {
          fs.unlinkSync(filePath)
          // console.log(`Deleted: ${filePath}`); // Optional: more verbose logging
        }
      } catch (unlinkError) {
        console.error(`Error deleting ${filePath}:`, unlinkError)
      }
    })
  } else {
    console.log(`Creating target folder: ${target}`)
    fs.mkdirSync(target, { recursive: true }) // Ensure parent dirs are created if needed
  }
}

function matchesIgnoredPattern(filename) {
  return config.ignoredPatterns.some((pattern) => {
    if (pattern.startsWith('*.')) {
      return filename.endsWith(pattern.slice(1))
    }
    // Add more complex pattern matching here if needed
    return false
  })
}

function matchesFilter(fullPath, relativePath, originalName) {
  if (!filterArg) return true
  // Filter based on the constructed name (path_parts_originalName)
  const folderParts = relativePath
    .split(path.sep)
    .filter((part) => part.length > 0)
  const constructedNameBase =
    folderParts.length > 0
      ? `${folderParts.join('_')}_${originalName}`
      : originalName
  return constructedNameBase.toLowerCase().includes(filterArg.toLowerCase())
}

function createInternalReadme() {
  const readmeContent = `# Pipe Folder Overview

This folder contains a flattened version of the project structure from the parent directory, prepared for Large Language Model (LLM) ingestion.

## Naming Convention
- Files are renamed to \`folder_subfolder_filename.ext\`.
- Files from the root retain their original name.
- Extensions in \`extensionsToAppendTxt\` (and files with no extension) have \`.txt\` appended (e.g., \`main.js\` -> \`main.js.txt\`, \`Dockerfile\` -> \`Dockerfile.txt\`).

## Source Configuration Used
- **Target Folder:** ${config.targetFolder}
- **Ignored Folders:** ${config.ignoredFolders.join(', ')}
- **Ignored Files:** ${config.ignoredFiles.join(', ')}
- **Ignored Patterns:** ${config.ignoredPatterns.join(', ')}
- **Append .txt to:** ${config.extensionsToAppendTxt.join(
    ', '
  )} (and files with no extension)
${
  filterArg
    ? `\n- **Filter Applied:** Only files containing "${filterArg}" in their path/name were included.`
    : ''
}

Generated by pied-piper.js
`
  const readmePath = path.join(config.targetFolder, 'README.md')
  try {
    fs.writeFileSync(readmePath, readmeContent)
    console.log(`Created internal README: ${readmePath}`)
  } catch (error) {
    console.error(`Error writing internal README: ${error}`)
  }
}

function processDirectory(currentDir, baseDir) {
  let items
  try {
    items = fs.readdirSync(currentDir)
  } catch (error) {
    console.error(`Error reading directory ${currentDir}:`, error)
    return
  }

  for (const item of items) {
    const fullPath = path.join(currentDir, item)
    // Construct relative path from the initial base directory
    const relativePathToItem = path.relative(baseDir, fullPath)

    // Skip target folder itself and globally ignored folders early
    if (item === config.targetFolder || config.ignoredFolders.includes(item)) {
      // console.log(`Skipping ignored folder directly: ${fullPath}`);
      continue
    }
    // Skip if the item is within an ignored folder path segment
    if (
      config.ignoredFolders.some((ignored) =>
        relativePathToItem.split(path.sep).includes(ignored)
      )
    ) {
      // console.log(`Skipping item within ignored path: ${fullPath}`);
      continue
    }

    let stat
    try {
      stat = fs.statSync(fullPath)
    } catch (error) {
      console.error(`Error getting stats for ${fullPath}:`, error)
      continue
    }

    if (stat.isDirectory()) {
      processDirectory(fullPath, baseDir) // Recurse
    } else if (stat.isFile()) {
      const originalName = path.basename(item)
      const relativeDirPath = path.relative(baseDir, currentDir) // Path relative to base, for naming

      // Skip ignored files or patterns
      if (
        config.ignoredFiles.includes(originalName) ||
        matchesIgnoredPattern(originalName)
      ) {
        // console.log(`Skipping ignored file/pattern: ${fullPath}`);
        continue
      }

      // Check filter
      if (!matchesFilter(fullPath, relativeDirPath, originalName)) {
        // console.log(`Skipping file not matching filter: ${fullPath}`);
        continue
      }

      // Construct new filename
      const folderParts = relativeDirPath
        .split(path.sep)
        .filter((part) => part.length > 0)
      let newName =
        folderParts.length > 0
          ? `${folderParts.join('_')}_${originalName}`
          : originalName

      // Handle extensions: Append .txt where needed
      const ext = path.extname(originalName) // Check original extension
      if (
        config.extensionsToAppendTxt.includes(ext) ||
        (!ext && originalName !== '.gitignore')
      ) {
        // Append .txt if in list or no extension (excluding special cases like .gitignore if desired)
        newName += '.txt'
      }

      const targetPath = path.join(config.targetFolder, newName)

      // Copy file
      try {
        // Ensure target directory exists before copying (relevant if targetFolder is nested)
        fs.mkdirSync(path.dirname(targetPath), { recursive: true })
        fs.copyFileSync(fullPath, targetPath)
        console.log(
          `Copied: ${path.relative(baseDir, fullPath)} -> ${path.join(
            config.targetFolder,
            newName
          )}`
        )
      } catch (error) {
        console.error(`Error copying ${fullPath} to ${targetPath}:`, error)
      }
    }
  }
}

// --- Execution ---
console.log('Starting Pied Piper file organization...')
try {
  clearTargetFolder()
  processDirectory('.', '.') // Start processing from the current directory
  createInternalReadme()
  console.log('File organization complete!')
  console.log(`Output generated in: ${config.targetFolder}`)
} catch (error) {
  console.error('An unexpected error occurred during processing:', error)
  process.exit(1) // Exit with error code
}
